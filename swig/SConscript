#
# SWIG - Simplified Wrapper and Interface Generator
#
# Generate interfaces to libcmyth for other languages.
#

import os
import sys
import shutil
from distutils import sysconfig

import SCons.Util

Import('env')

prefix = env['PREFIX']
platform = env['PLATFORM']

targets = []

interface = [ 'cmyth.i', Glob('../include/*.h'), Glob('../include/*/*.h') ]
cmd = 'swig -c++ -%s -Iinclude -o swig/%s swig/cmyth.i'
cmd_python = 'swig -c++ -threads -%s -Iinclude -o swig/%s swig/cmyth.i'
cmd_c = 'swig -%s -Iinclude -o swig/%s swig/cmyth.i'
cmd_java = 'swig -c++ -%s -package %s -outdir %s -o swig/%s -Iinclude swig/cmyth.i'

def CheckBinary(context, name):
    context.Message('Checking for %s ...' % name)
    ret = SCons.Util.WhereIs(name)
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

def CheckJava(context):
    context.Message('Checking for Java headers ...')
    dirs = [ '/usr/lib/jvm/default-java',
             '/System/Library/Frameworks/JavaVM.framework' ]
    ret = None
    for dir in dirs:
        if os.path.isdir(dir):
            ret = dir
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

def CheckPHP(context):
    context.Message('Checking for PHP headers ...')
    cmd = context.env['CMD_PHPCONFIG']
    ret = None
    if cmd:
        rc,phpinc,err = context.env.run_command('%s --include-dir' % cmd)
        ret = phpinc[:-1]
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

def CheckRuby(context):
    context.Message('Checking for Ruby headers ...')
    cmd = context.env['CMD_RUBY']
    ret = None
    if cmd:
        rc,rubyarch,err = env.run_command('ruby -rrbconfig -e '
                                          '\'puts Config::CONFIG["archdir"]\'')
        ret = rubyarch[:-1]
        if not os.path.isfile(ret + '/ruby.h'):
            ret = None
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

def CheckLisp(context):
    context.Message('Checking for Common Lisp ...')
    lisp = []
    ret = None
    for l in [ 'sbcl', 'ccl', 'ecl', 'clisp' ]:
        cmd = SCons.Util.WhereIs(l)
        if cmd:
            lisp += [ cmd ]
    if len(lisp) > 0:
        ret = lisp[0]
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

def CheckPerl(context):
    context.Message('Checking for Perl headers ...')
    cmd = context.env['CMD_PERL']
    ret = None
    if cmd:
        rc,perlarch,err = env.run_command('perl -e \'use Config; print '
                                          '"$Config{archlib}\n";\'')
        ret = perlarch[:-1]
    if ret == None:
        context.Result('no')
    else:
        context.Result(ret)
    return ret

env['CMD_JAVAC'] = None
env['JAVA_HOME'] = None
env['CMD_PHP'] = None
env['CMD_PHPCONFIG'] = None
env['PHP_INCLUDE'] = None
env['CMD_PYTHON'] = None
env['CMD_RUBY'] = None
env['CMD_GEM'] = None
env['CMD_RUBYARCH'] = None
env['CMD_LISP'] = None
env['CMD_PERL'] = None
env['CMD_PERLARCH'] = None

conf = Configure(env, custom_tests = { 'CheckBinary' : CheckBinary,
                                       'CheckJava' : CheckJava,
                                       'CheckRuby' : CheckRuby,
                                       'CheckLisp' : CheckLisp,
                                       'CheckPerl' : CheckPerl,
                                       'CheckPHP': CheckPHP })
env['CMD_SWIG'] = conf.CheckBinary('swig')
if env['CMD_SWIG']:
    if env['PLATFORM'] != 'ios':
        env['CMD_JAVAC'] = conf.CheckBinary('javac')
        env['JAVA_HOME'] = conf.CheckJava()
    if not env['PLATFORM'] in [ 'android', 'ios' ]:
        env['CMD_PHP'] = conf.CheckBinary('php')
        env['CMD_PHPCONFIG'] = conf.CheckBinary('php-config')
        env['PHP_INCLUDE'] = conf.CheckPHP()
        env['CMD_PYTHON'] = conf.CheckBinary('python')
        env['CMD_RUBY'] = conf.CheckBinary('ruby')
        env['CMD_GEM'] = conf.CheckBinary('gem')
        env['CMD_RUBYARCH'] = conf.CheckRuby()
        env['CMD_LISP'] = conf.CheckLisp()
        env['CMD_PERL'] = conf.CheckBinary('perl')
        env['CMD_PERLARCH'] = conf.CheckPerl()
env = conf.Finish()

#
# Python
#
if env['CMD_PYTHON'] != None:
    libs = [ 'cppmyth', 'cmyth', 'refmem' ]
    if sys.platform == 'darwin':
        libs += [ 'python' ]
    python = env.Command([ 'cmyth_python.cpp', 'cmyth.py' ],
                         interface,
                         [ cmd_python % ('python', 'cmyth_python.cpp') ])
    targets += python
    shared = env.SharedLibrary('cmyth_python',
                               [ 'cmyth_python.cpp' ],
                               SHLIBSUFFIX = '.so',
                               LIBS = libs,
                               CCFLAGS = '',
                               CXXFLAGS = '',
                               CPPPATH = [ '../include', '.',
                                           sysconfig.get_python_inc() ],
                               LIBPATH = [ '../libcppmyth',
                                           '../libcmyth',
                                           '../librefmem' ])
    targets += shared
    link_so = env.Symlink('python/_cmyth.so', 'libcmyth_python.so')
    targets += link_so
    link_py = env.Symlink('python/cmyth.py', 'cmyth.py')
    targets += link_py
    version = '0.0.1'
    setup = env.GenSetup('python/setup.py',
                         [ link_so, link_py, 'python/__init__.py' ],
                         SETUP_NAME = 'cmyth',
                         SETUP_VERSION = version,
                         SETUP_DESCRIPTION =
                         'An API for communicating with a MythTV backend.',
                         SETUP_AUTHOR = 'Jon Gettler',
                         SETUP_AUTHOR_EMAIL = 'gettler@mvpmc.org',
                         SETUP_URL = 'http://cmyth.github.com/',
                         SETUP_LICENSE = 'LGPL',
                         SETUP_DIR = 'swig/python')
    targets += setup

    if env.GetOption('clean'):
        try:
            os.unlink('cmyth.pyc')
        except:
            pass

#
# PHP
#
if env['CMD_PHP'] != None and env['CMD_PHPCONFIG'] != None and env['PHP_INCLUDE'] != None:
    php = env.Command([ 'cmyth_php.cpp', 'php_cmyth.h', 'cmyth.php' ],
                      interface,
                      [ cmd % ('php', 'cmyth_php.cpp') ])
    targets += php
    phpinc = env['PHP_INCLUDE']
    if sys.platform == 'darwin':
        linkflags = '-Wl,-flat_namespace,-undefined,warning'
    else:
        linkflags = ''
    shared = env.SharedLibrary('cmyth_php',
                               [ 'cmyth_php.cpp' ],
                               SHLIBSUFFIX = '.so',
                               LIBS = [ 'cppmyth', 'cmyth', 'refmem' ],
                               CCFLAGS = '',
                               CXXFLAGS = '',
                               LINKFLAGS = linkflags,
                               CPPPATH = [ '../include', '.',
                                           phpinc,
                                           phpinc + '/main',
                                           phpinc + '/TSRM',
                                           phpinc + '/Zend' ],
                               LIBPATH = [ '../libcppmyth',
                                           '../libcmyth',
                                           '../librefmem' ])
    targets += shared
    link = env.Symlink('php/cmyth.so', 'libcmyth_php.so')
    targets += link

    if env.GetOption('clean'):
        try:
            shutil.rmtree('php')
        except:
            pass

#
# Ruby
#
if env['CMD_RUBY'] != None and env['CMD_RUBYARCH'] != None:
    rubyarch = env['CMD_RUBYARCH']
    libs = [ 'cppmyth', 'cmyth', 'refmem' ]
    suffix = '.so'
    if sys.platform == 'darwin':
        libs += [ 'ruby' ]
        suffix = '.bundle'
    ruby = env.Command([ 'cmyth_ruby.cpp' ],
                       interface,
                       [ cmd % ('ruby', 'cmyth_ruby.cpp') ])
    targets += ruby
    shared = env.SharedLibrary('cmyth_ruby',
                               [ 'cmyth_ruby.cpp' ],
                               SHLIBSUFFIX = '.so',
                               CCFLAGS = '',
                               CXXFLAGS = '',
                               LIBS = libs,
                               CPPPATH = [ '../include', '.',
                                           rubyarch ],
                               LIBPATH = [ '../libcppmyth',
                                           '../libcmyth',
                                           '../librefmem' ])
    targets += shared
    link = env.Symlink('ruby/lib/cmyth.so', 'libcmyth_ruby.so')
    targets += link
    version = '0.0.1'
    gem = env.GenGemspec('ruby/cmyth.gemspec', link,
                         GEM_NAME = 'cmyth',
                         GEM_VERSION = version,
                         GEM_SUMMARY = 'cmyth MythTV API',
                         GEM_DESCRIPTION = 'API for communicating with a MythTV backend.',
                         GEM_AUTHORS = 'Jon Gettler',
                         GEM_EMAIL = 'gettler@mvpmc.org',
                         GEM_HOMEPAGE = 'http://cmyth.github.com/',
                         GEM_DIR = 'swig/ruby')
    targets += gem

    if env['CMD_GEM'] != None:
        gem = env.Command([ 'ruby/cmyth-%s.gem' % version ],
                          [ gem, link ],
                          'cd swig/ruby && gem build cmyth.gemspec')
        targets += gem


    if env.GetOption('clean'):
        try:
            shutil.rmtree('ruby')
        except:
            pass

#
# Java
#
if env['CMD_JAVAC'] != None and env['JAVA_HOME'] != None:
    javapath = env['JAVA_HOME']
    if os.path.isfile(javapath + '/include/jni.h') or \
            os.path.isfile(javapath + '/Headers/jni.h'):
        path = 'org/mvpmc/cmyth/java'
        try:
            os.makedirs(path)
        except:
            pass
        bases = [ 'cmyth', 'cmythJNI', 'cmythConstants',
                  'SWIGTYPE_p_cmyth_conn_t',
                  'SWIGTYPE_p_cmyth_proglist_t',
                  'SWIGTYPE_p_cmyth_proginfo_t',
                  'SWIGTYPE_p_cmyth_event_t',
                  'SWIGTYPE_p_cmyth_channeldir_t',
                  'SWIGTYPE_p_cmyth_browsedir_t',
                  'SWIGTYPE_p_cmyth_recorder_t',
                  'SWIGTYPE_p_cmyth_chanlist_t',
                  'filetype_t', 'progtype_t',
                  'connection', 'exception', 'proginfo', 'proglist',
                  'refmem', 'file', 'event', 'livetv', 'recorder',
                  'chanlist', 'channel' ]
        src_list = []
        for i in bases:
            src_list.append(path + '/' + i + '.java')
        src = ''
        for i in src_list:
            src = src + ' ' + i
        classes = ''
        for i in bases:
            classes = classes + path + '/' + i + '.class '
        src_list.append('cmyth_java.cpp')
        java = env.Command(src_list,
                           interface,
                           [ cmd_java % ('java', 'org.mvpmc.cmyth.java',
                                         'swig/' + path, 'cmyth_java.cpp') ])
        targets += java
        if sys.platform == 'darwin':
            suffix = '.jnilib'
            linkflags = [ 'librefmem/librefmem.a',
                          'libcmyth/libcmyth.a',
                          'libcppmyth/libcppmyth.a' ]
            libs = [ ]
            libpath = [ ]
        else:
            suffix = '.so'
            linkflags = [ ]
            libs = [ 'cppmyth', 'cmyth', 'refmem' ]
            libpath = [ '../libcppmyth', '../libcmyth', '../librefmem' ]
        if platform == 'android':
            makefile = env.NDK('cmyth_java', 'cmyth_java.cpp',
                               LIBS = [ 'cppmyth', 'refmem' ],
                               LIBDIRS = [ '../libcppmyth', '../librefmem' ],
                               INCLUDES = [ '../include', '.' ])
            targets += makefile
            env.Install(prefix + '/lib', makefile)
        else:
            shared = env.SharedLibrary('cmyth_java',
                                       [ 'cmyth_java.cpp' ],
                                       SHLIBSUFFIX = suffix,
                                       CCFLAGS = '',
                                       CXXFLAGS = '',
                                       LINKFLAGS = linkflags,
                                       LIBS = libs,
                                       LIBPATH = libpath,
                                       CPPPATH = [ '../include', '.',
                                                   javapath + '/include',
                                                   javapath + '/Headers', ])
            targets += shared
        output = env.Command(path + '/cmyth.class',
                             java,
                             [ 'cd swig && %s -d %s -sourcepath %s %s' %
                               (env['CMD_JAVAC'], '.', path, src) ])
                                  
        jar = env.Command('cmyth.jar', output,
                          [ 'cd swig && jar cf cmyth.jar %s' % classes ])
        targets += jar

        if not platform == 'android':
            env.Install(prefix + '/lib', shared)
        env.Install(prefix + '/lib', jar)

        if env.GetOption('clean'):
            for i in [ 'org', 'libs', 'jni', 'obj' ]:
                try:
                    shutil.rmtree(i)
                except:
                    pass

#
# Common Lisp
#
if env['CMD_LISP'] != None:
    lisp = env.Command([ 'cmyth.lisp' ],
                       interface,
                       [ cmd_c % ('cffi', 'cmyth.lisp') ])
    targets += lisp
    package = env.CatFiles([ 'lisp/cmyth.lisp' ],
                           [ lisp],
                           HEADER = '(in-package #:cmyth)')
    targets += package
    setup = env.GenASDF('lisp/cmyth.asd',
                        [ 'lisp/package.lisp',
                          lisp,
                          'lisp/cffi.lisp',
                          'lisp/refmem.lisp', 'lisp/exception.lisp',
                          'lisp/connection.lisp', 'lisp/file.lisp',
                          'lisp/proginfo.lisp', 'lisp/debug.lisp' ],
                        ASDF_NAME = 'cmyth',
                        ASDF_DESCRIPTION =
                        'An API for communicating with a MythTV backend.',
                        ASDF_AUTHOR = 'Jon Gettler <gettler@mvpmc.org>',
                        ASDF_LICENSE = 'LLGPL',
                        ASDF_DEPENDS = [ 'cffi', 'trivial-garbage' ],
                        ASDF_DIR = 'swig/lisp')
    targets += setup

#
# Perl
#
if env['CMD_PERL'] != None and env['CMD_PERLARCH'] != None:
    perlarch = env['CMD_PERLARCH']
    perl = env.Command([ 'cmyth_perl.cpp', 'cmyth.pm' ],
                       interface,
                       [ cmd % ('perl', 'cmyth_perl.cpp') ])
    targets += perl
    if sys.platform == 'darwin':
        linkflags = '-Wl,-flat_namespace,-undefined,warning'
    else:
        linkflags = ''
    libs = [ 'cppmyth', 'cmyth', 'refmem' ]
    shared = env.SharedLibrary('cmyth_perl',
                               [ 'cmyth_perl.cpp' ],
                               SHLIBSUFFIX = '.so',
                               LIBS = libs,
                               CCFLAGS = '',
                               CXXFLAGS = '',
                               LINKFLAGS = linkflags,
                               CPPPATH = [ '../include', '.',
                                           '%s/CORE' % perlarch ],
                               LIBPATH = [ '../libcppmyth',
                                           '../libcmyth',
                                           '../librefmem' ])
    targets += shared
    link = env.Symlink('perl/cmyth.so', 'libcmyth_perl.so')
    targets += link
    link = env.Symlink('perl/cmyth.pm', 'cmyth.pm')
    targets += link

Return('targets')
